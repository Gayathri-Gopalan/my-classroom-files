<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UCM Simulation (Velocity vs Radius)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    canvas {
      border: 1px solid black;
      background-color: #f9f9f9;
      display: block;
      margin: 20px auto;
    }
    .controls, .measurements {
      margin: 15px auto;
      width: 80%;
      text-align: left;
    }
    .controls label, .measurements div {
      display: block;
      margin: 8px 0;
    }
    .controls input[type=range] {
      width: 250px;
    }
  </style>
</head>
<body>
  <h2>Uniform Circular Motion Simulation</h2>
  <canvas id="ucmCanvas" width="600" height="600"></canvas>

  <div class="controls">
    <label>Angular Velocity (rad/s): <input type="range" id="omegaSlider" min="0.1" max="5" step="0.1" value="1"> <span id="omegaValue">1.0</span></label>
    <label>Radius (m): <input type="range" id="radiusSlider" min="0.5" max="2.5" step="0.1" value="1.5"> <span id="radiusValue">1.5</span></label>
    <label>Mass (kg): <input type="range" id="massSlider" min="0.5" max="5" step="0.1" value="1"> <span id="massValue">1.0</span></label>
    <label><input type="checkbox" id="showForceCheckbox"> Show Centripetal Force</label>
    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
  </div>

  <div class="measurements">
    <div>Linear Speed (v): <span id="speedValue">0.00</span> m/s</div>
    <div>Period (T): <span id="periodValue">0.00</span> s</div>
    <div>Frequency (f): <span id="frequencyValue">0.00</span> Hz</div>
    <div>Centripetal Force (Fc): <span id="centripetalForceValue">0.00</span> N</div>
  </div>

  <script>
    class UCMSimulation {
      constructor() {
        this.canvas = document.getElementById('ucmCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.center = { x: this.canvas.width / 2, y: this.canvas.height / 2 };

        this.radius = 1.5; // meters
        this.mass = 1.0;
        this.angularVelocity = 1.0; // rad/s

        this.angle = 0;
        this.isPlaying = false;
        this.showCentripetalForce = false;

        this.lastTime = null;
        this.setupControls();
        this.updateMeasurements();
        this.draw();
      }

      setupControls() {
        const omegaSlider = document.getElementById('omegaSlider');
        const radiusSlider = document.getElementById('radiusSlider');
        const massSlider = document.getElementById('massSlider');
        const showForceCheckbox = document.getElementById('showForceCheckbox');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');

        omegaSlider.addEventListener('input', (e) => {
          this.angularVelocity = parseFloat(e.target.value);
          document.getElementById('omegaValue').textContent = this.angularVelocity.toFixed(1);
          this.updateMeasurements();
          if (!this.isPlaying) this.draw();
        });

        radiusSlider.addEventListener('input', (e) => {
          this.radius = parseFloat(e.target.value);
          document.getElementById('radiusValue').textContent = this.radius.toFixed(1);
          this.updateMeasurements();
          if (!this.isPlaying) this.draw();
        });

        massSlider.addEventListener('input', (e) => {
          this.mass = parseFloat(e.target.value);
          document.getElementById('massValue').textContent = this.mass.toFixed(1);
          this.updateMeasurements();
          if (!this.isPlaying) this.draw();
        });

        showForceCheckbox.addEventListener('change', (e) => {
          this.showCentripetalForce = e.target.checked;
          if (!this.isPlaying) this.draw();
        });

        playBtn.addEventListener('click', () => this.play());
        pauseBtn.addEventListener('click', () => this.pause());
        resetBtn.addEventListener('click', () => this.reset());
      }

      updateMeasurements() {
        this.speed = this.angularVelocity * this.radius;  // <-- ensures v changes when r changes

        const circumference = 2 * Math.PI * this.radius;
        const period = circumference / this.speed;
        const frequency = 1 / period;
        const centripetalForce = (this.mass * this.speed * this.speed) / this.radius;

        document.getElementById('speedValue').textContent = this.speed.toFixed(2);
        document.getElementById('periodValue').textContent = period.toFixed(2);
        document.getElementById('frequencyValue').textContent = frequency.toFixed(2);
        document.getElementById('centripetalForceValue').textContent = centripetalForce.toFixed(2);
      }

      play() {
        if (!this.isPlaying) {
          this.isPlaying = true;
          this.lastTime = null;
          requestAnimationFrame(this.animate.bind(this));
        }
      }

      pause() { this.isPlaying = false; }

      reset() {
        this.isPlaying = false;
        this.angle = 0;
        this.updateMeasurements();
        this.draw();
      }

      animate(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const deltaTime = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.angle += this.angularVelocity * deltaTime;
        this.draw();

        if (this.isPlaying) requestAnimationFrame(this.animate.bind(this));
      }

      draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        const pixelRadius = this.radius * 100; // scale meters to pixels

        ctx.beginPath();
        ctx.arc(this.center.x, this.center.y, pixelRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'blue';
        ctx.stroke();

        const objX = this.center.x + pixelRadius * Math.cos(this.angle);
        const objY = this.center.y + pixelRadius * Math.sin(this.angle);

        ctx.beginPath();
        ctx.arc(objX, objY, 12, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();

        if (this.showCentripetalForce) {
          const dx = this.center.x - objX;
          const dy = this.center.y - objY;
          const length = Math.sqrt(dx * dx + dy * dy);
          const unitX = dx / length;
          const unitY = dy / length;

          const forceMag = (this.mass * this.speed * this.speed) / this.radius;
          const scale = 20;
          const arrowX = objX + unitX * (forceMag / scale);
          const arrowY = objY + unitY * (forceMag / scale);

          ctx.beginPath();
          ctx.moveTo(objX, objY);
          ctx.lineTo(arrowX, arrowY);
          ctx.strokeStyle = 'green';
          ctx.lineWidth = 2;
          ctx.stroke();

          const headlen = 10;
          const angle = Math.atan2(arrowY - objY, arrowX - objX);
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(arrowX - headlen * Math.cos(angle - Math.PI / 6), arrowY - headlen * Math.sin(angle - Math.PI / 6));
          ctx.lineTo(arrowX - headlen * Math.cos(angle + Math.PI / 6), arrowY - headlen * Math.sin(angle + Math.PI / 6));
          ctx.closePath();
          ctx.fillStyle = 'green';
          ctx.fill();
        }
      }
    }

    window.onload = () => new UCMSimulation();
  </script>
</body>
</html>
